# Phase 2 Implementation Plan: Enhanced Functionality & Technical Excellence

*Generated: July 10, 2025*

## 1. Overview

Following the successful completion of Phase 1, Phase 2 focuses on delivering high-impact user features, addressing key technical debt, and preparing the application for multi-user, production-ready deployment. This plan breaks down the work into logical, sequential sub-phases to ensure steady progress and maintain architectural integrity.

## 2. Phase 2 Sub-Phases

Phase 2 is divided into four main sub-phases, each with a clear focus:

- **Phase 2a: Core Interactions & Testing Foundation** - **COMPLETED**
- **Phase 2b: Authentication & User Scope** - **IN PROGRESS**
- **Phase 2c: Rich Content & Enhanced Metadata** - Add features that enrich the card and board data.
- **Phase 2d: Quality, Performance & Production Readiness** - Focus on hardening the application, optimizing performance, and finalizing production setup.

---

## 3. Phase 2a: Core Interactions & Testing Foundation

**Status: COMPLETED**

**Focus**: Implement the highest-priority user featureâ€”drag-and-dropâ€”and build the initial testing infrastructure to support it.

### 3.1. Feature: Drag & Drop (`@dnd-kit`)
- **Problem**: Users cannot reorder cards and lists visually, which is a core Kanban experience.
- **Technical Approach**:
    - Integrate `@dnd-kit` for its robust, accessible, and framework-agnostic drag-and-drop capabilities.
    - Implement `DndContext` at the board level.
    - Create sortable contexts for both lists and cards within lists.
    - Develop new API endpoints (`/cards/:id/move`, `/lists/:id/move`) to handle position updates.
    - Use optimistic UI updates in RTK Query to provide immediate visual feedback during drag operations.
- **Implementation Steps**:
    1. âœ… Install `@dnd-kit/core`, `@dnd-kit/sortable`.
    2. âœ… Create a `DragDropProvider` component to encapsulate the DnD context.
    3. âœ… Make `List` and `Card` components draggable using `useDraggable` and `useSortable`.
    4. âœ… Implement `handleDragEnd` logic to dispatch API calls for reordering.
    5. âœ… Update Prisma schema (`position` fields to `Float`) and services to use decimal-based positioning for efficient reordering.

### 3.2. Technical Debt: E2E & Component Tests
- **Problem**: No automated tests exist for frontend user interactions.
- **Technical Approach**:
    - Use Playwright to create E2E tests for the new drag-and-drop functionality.
    - Use Vitest and React Testing Library to create unit/integration tests for the key DnD components.
- **Implementation Steps**:
    1. âœ… Write a Playwright test spec (`dnd.spec.ts`) that simulates dragging a card between lists and verifies the final state.
    2. âœ… Write component tests for `KanbanCard` and `List` to ensure they respond correctly to drag events.

---

## 4. Phase 2b: Authentication & User Scope

**Status: IN PROGRESS**

**Focus**: Transition from a single-user application to a multi-user, secure platform using Firebase Authentication.

### 4.1. Feature: Firebase Authentication
- **Problem**: The application lacks user accounts, security, and data isolation.
- **Technical Approach**:
    - Integrate Firebase Auth for Google and GitHub sign-in.
    - Update the Prisma schema to associate all data (boards, lists, cards) with a `userId`.
    - Create backend middleware to validate Firebase JWTs and attach the user to the request object.
    - Refactor all API service logic to be user-aware, ensuring users can only access their own data.
- **Implementation Steps**:
    1. âœ… Set up a new Firebase project and configure Auth.
    2. âœ… Add `User` model to `schema.prisma` and link it to the `Board` model.
    3. âœ… Create `authMiddleware` in the backend to protect all routes.
    4. âœ… Update all database queries to include a `where: { userId: ... }` clause.
    5. ðŸ”˜ **Implement Frontend Authentication Flow:**
        - **Sign-Up Page**: Create a new `SignUpPage.tsx` with a form to register users via Firebase's `createUserWithEmailAndPassword` function. Link to this page from the `LoginPage`.
          - **Problem Statement**: Users need a way to register for an account using email and password.
          - **Requirements**:
            - Form fields for email, password, and a "confirm password" field.
            - Optional field for display name.
            - Validation for email format, password strength, and ensuring passwords match.
            - Error handling for duplicate email, weak password, and network issues.
            - Link to the login page for existing users.
          - **Technical Approach**:
            - Use Firebaseâ€™s `createUserWithEmailAndPassword` for registration.
            - On success, update Redux `authSlice` with user info and JWT.
            - Redirect to the main app (e.g., `/boards`) after successful sign-up.
            - Display error messages for failed registration attempts.
          - **Implementation Steps**:
            1. Create `SignUpPage.tsx` in `src/frontend/src/pages/`.
            2. Implement the form with Tailwind CSS and ShadCN/UI components, including a "confirm password" field.
            3. Add form validation, including a check that passwords match, and error display.
            4. Integrate Firebase registration logic.
            5. Update Redux store on success.
            6. Add navigation link to login page.
            7. Add navigation link from login page to sign-up page.
          - **Testing Strategy**:
            - Unit test form validation logic with Vitest.
            - Component test registration flow with React Testing Library.
            - E2E test: Register a new user and verify login and redirect.
          - **Risks & Mitigation**:
            - Duplicate email: Show clear error message.
            - Network errors: Display retry option.
          - **Dependencies**:
            - Firebase Auth SDK
            - Redux Toolkit `authSlice`
            - React Router
        - **Google Sign-In**: Add a "Sign in with Google" button to `LoginPage.tsx` that uses Firebase's `signInWithPopup` and the `GoogleAuthProvider`.
        - **State Management**: Ensure the Redux `authSlice` correctly handles user state for sign-up, email login, and Google Sign-in, storing the JWT and user info.
        - **Protected Routes**: Implement a `<ProtectedRoute />` component that wraps authenticated routes and redirects unauthenticated users to the login page.
    6. ðŸ”˜ **Implement Logout & Profile Page:**
        - **Logout**: Create a `useLogout` hook that calls Firebase's `signOut()`, clears the Redux auth state, and redirects to the login page. Add a logout button to the main application header.
        - **Profile Page**: Create a basic, view-only `ProfilePage.tsx` that displays the user's email and display name from the Redux store.
    
- **Note on Session Duration**: Revisit the indefinite session length. While Firebase handles automatic token refreshes for a persistent user session, we should evaluate implementing a session timeout or a "remember me" option for enhanced security in a future phase.

---

## 5. Phase 2c: Rich Content & Enhanced Metadata

**Focus**: Enhance the value of cards by adding more detailed information and tracking history.

### 5.1. Feature: Rich Content & Metadata
- **Problem**: Cards are limited to a title and description. Users need labels, due dates, and rich text formatting.
- **Technical Approach**:
    - **Rich Editing**: Integrate a lightweight Markdown library (e.g., `react-markdown`) to render card descriptions.
    - **Labels & Due Dates**:
        - Extend the `Card` model in `schema.prisma` to include `dueDate` (DateTime) and a many-to-many relation to a new `Label` model.
        - Create new API endpoints for managing labels (`/api/labels`).
        - Update the `CardModal` component to include UI for setting a due date and assigning labels.
- **Implementation Steps**:
    1. Add `Label` and `Activity` models to the Prisma schema and update the `Card` model.
    2. Build the backend API for CRUD operations on labels.
    3. Update the frontend `Card` component and `CardModal` to display and edit this new metadata.
    4. Implement `react-markdown` in the `CardModal` for the description field.

### 5.2. Feature: Activity History
- **Problem**: There is no audit trail for changes made to cards.
- **Technical Approach**:
    - Create an `Activity` model in Prisma linked to cards.
    - In the backend, create a generic `createActivity` service that is called from other services (e.g., after updating a card's title, moving a card).
    - Display the activity feed within the `CardModal`.
- **Implementation Steps**:
    1. Add the `Activity` model to `schema.prisma`.
    2. Implement the backend logic to log activities for all relevant card and list mutations.
    3. Add an "Activity" section to the `CardModal` component that fetches and displays the history.

---

## 6. Phase 2d: Quality, Performance & Production Readiness

**Focus**: Address remaining technical debt, optimize for large datasets, and finalize the production environment.

### 6.1. Technical Debt: Testing, Performance & Errors
- **Problem**: The application needs comprehensive testing, performance tuning, and more robust error handling.
- **Technical Approach**:
    - **Testing**: Achieve 80%+ component test coverage. Write E2E tests for all critical user flows (auth, board creation, etc.).
    - **Performance**:
        - Implement virtualization (`react-virtual`) for lists and cards to handle boards with thousands of items.
        - Analyze and optimize expensive database queries.
    - **Error Boundaries**: Wrap key feature areas in React Error Boundaries to prevent UI crashes.
- **Implementation Steps**:
    1. Write comprehensive component tests for all pages and business components.
    2. Implement `useVirtual` hook for rendering long lists of cards.
    3. Wrap the main `BoardDetailPage` in an `ErrorBoundary` component.

### 6.2. Feature: Search
- **Problem**: Users cannot find cards across the entire application.
- **Technical Approach**:
    - Implement a new backend endpoint (`/api/search?q=...`) that performs a full-text search across card titles and descriptions for the authenticated user.
    - Add a global search bar to the application layout.
- **Implementation Steps**:
    1. Create the search endpoint in the backend.
    2. Add a search input to the frontend `Header` component.
    3. Display search results in a dropdown or a dedicated search results page.

### 6.3. Technical Debt: Production Docker & CI/CD
- **Problem**: The Docker setup is not optimized for production.
- **Technical Approach**:
    - Refine the `Dockerfile` to use multi-stage builds for smaller, more secure production images.
    - Ensure all secrets and environment variables are handled correctly.
    - Set up a basic CI/CD pipeline using GitHub Actions to build, test, and (optionally) deploy the application.
- **Implementation Steps**:
    1. Optimize the `Dockerfile` and `docker-compose.yml` for a production environment.
    2. Create a GitHub Actions workflow file to run tests on every push.
