# Phase 2 Implementation Plan: Enhanced Functionality & Technical Excellence

*Generated: July 10, 2025*

## 1. Overview

Following the successful completion of Phase 1, Phase 2 focuses on delivering high-impact user features, addressing key technical debt, and preparing the application for multi-user, production-ready deployment. This plan breaks down the work into logical, sequential sub-phases to ensure steady progress and maintain architectural integrity.

## 2. Phase 2 Sub-Phases

Phase 2 is divided into four main sub-phases, each with a clear focus:

- **Phase 2a: Core Interactions & Testing Foundation** - Introduce drag-and-drop and establish baseline testing for it.
- **Phase 2b: Authentication & User Scope** - Integrate Firebase Auth and make the application multi-tenant.
- **Phase 2c: Rich Content & Enhanced Metadata** - Add features that enrich the card and board data.
- **Phase 2d: Quality, Performance & Production Readiness** - Focus on hardening the application, optimizing performance, and finalizing production setup.

---

## 3. Phase 2a: Core Interactions & Testing Foundation

**Focus**: Implement the highest-priority user feature—drag-and-drop—and build the initial testing infrastructure to support it.

### 3.1. Feature: Drag & Drop (`@dnd-kit`)
- **Problem**: Users cannot reorder cards and lists visually, which is a core Kanban experience.
- **Technical Approach**:
    - Integrate `@dnd-kit` for its robust, accessible, and framework-agnostic drag-and-drop capabilities.
    - Implement `DndContext` at the board level.
    - Create sortable contexts for both lists and cards within lists.
    - Develop new API endpoints (`/cards/:id/move`, `/lists/:id/move`) to handle position updates.
    - Use optimistic UI updates in RTK Query to provide immediate visual feedback during drag operations.
- **Implementation Steps**:
    1. Install `@dnd-kit/core`, `@dnd-kit/sortable`.
    2. Create a `DragDropProvider` component to encapsulate the DnD context.
    3. Make `List` and `Card` components draggable using `useDraggable` and `useSortable`.
    4. Implement `handleDragEnd` logic to dispatch API calls for reordering.
    5. Update Prisma schema (`position` fields to `Float`) and services to use decimal-based positioning for efficient reordering.

### 3.2. Technical Debt: E2E & Component Tests
- **Problem**: No automated tests exist for frontend user interactions.
- **Technical Approach**:
    - Use Playwright to create E2E tests for the new drag-and-drop functionality.
    - Use Vitest and React Testing Library to create unit/integration tests for the key DnD components.
- **Implementation Steps**:
    1. Write a Playwright test spec (`dnd.spec.ts`) that simulates dragging a card between lists and verifies the final state.
    2. Write component tests for `KanbanCard` and `List` to ensure they respond correctly to drag events.

---

## 4. Phase 2b: Authentication & User Scope

**Focus**: Transition from a single-user application to a multi-user, secure platform using Firebase Authentication.

### 4.1. Feature: Firebase Authentication
- **Problem**: The application lacks user accounts, security, and data isolation.
- **Technical Approach**:
    - Integrate Firebase Auth for Google and GitHub sign-in.
    - Update the Prisma schema to associate all data (boards, lists, cards) with a `userId`.
    - Create backend middleware to validate Firebase JWTs and attach the user to the request object.
    - Refactor all API service logic to be user-aware, ensuring users can only access their own data.
- **Implementation Steps**:
    1. Set up a new Firebase project and configure Auth.
    2. Add `User` model to `schema.prisma` and link it to the `Board` model.
    3. Create `authMiddleware` in the backend to protect all routes.
    4. Update all database queries to include a `where: { userId: ... }` clause.
    5. Implement frontend login page, auth state management (in a Redux slice), and routing guards.

---

## 5. Phase 2c: Rich Content & Enhanced Metadata

**Focus**: Enhance the value of cards by adding more detailed information and tracking history.

### 5.1. Feature: Rich Content & Metadata
- **Problem**: Cards are limited to a title and description. Users need labels, due dates, and rich text formatting.
- **Technical Approach**:
    - **Rich Editing**: Integrate a lightweight Markdown library (e.g., `react-markdown`) to render card descriptions.
    - **Labels & Due Dates**:
        - Extend the `Card` model in `schema.prisma` to include `dueDate` (DateTime) and a many-to-many relation to a new `Label` model.
        - Create new API endpoints for managing labels (`/api/labels`).
        - Update the `CardModal` component to include UI for setting a due date and assigning labels.
- **Implementation Steps**:
    1. Add `Label` and `Activity` models to the Prisma schema and update the `Card` model.
    2. Build the backend API for CRUD operations on labels.
    3. Update the frontend `Card` component and `CardModal` to display and edit this new metadata.
    4. Implement `react-markdown` in the `CardModal` for the description field.

### 5.2. Feature: Activity History
- **Problem**: There is no audit trail for changes made to cards.
- **Technical Approach**:
    - Create an `Activity` model in Prisma linked to cards.
    - In the backend, create a generic `createActivity` service that is called from other services (e.g., after updating a card's title, moving a card).
    - Display the activity feed within the `CardModal`.
- **Implementation Steps**:
    1. Add the `Activity` model to `schema.prisma`.
    2. Implement the backend logic to log activities for all relevant card and list mutations.
    3. Add an "Activity" section to the `CardModal` component that fetches and displays the history.

---

## 6. Phase 2d: Quality, Performance & Production Readiness

**Focus**: Address remaining technical debt, optimize for large datasets, and finalize the production environment.

### 6.1. Technical Debt: Testing, Performance & Errors
- **Problem**: The application needs comprehensive testing, performance tuning, and more robust error handling.
- **Technical Approach**:
    - **Testing**: Achieve 80%+ component test coverage. Write E2E tests for all critical user flows (auth, board creation, etc.).
    - **Performance**:
        - Implement virtualization (`react-virtual`) for lists and cards to handle boards with thousands of items.
        - Analyze and optimize expensive database queries.
    - **Error Boundaries**: Wrap key feature areas in React Error Boundaries to prevent UI crashes.
- **Implementation Steps**:
    1. Write comprehensive component tests for all pages and business components.
    2. Implement `useVirtual` hook for rendering long lists of cards.
    3. Wrap the main `BoardDetailPage` in an `ErrorBoundary` component.

### 6.2. Feature: Search
- **Problem**: Users cannot find cards across the entire application.
- **Technical Approach**:
    - Implement a new backend endpoint (`/api/search?q=...`) that performs a full-text search across card titles and descriptions for the authenticated user.
    - Add a global search bar to the application layout.
- **Implementation Steps**:
    1. Create the search endpoint in the backend.
    2. Add a search input to the frontend `Header` component.
    3. Display search results in a dropdown or a dedicated search results page.

### 6.3. Technical Debt: Production Docker & CI/CD
- **Problem**: The Docker setup is not optimized for production.
- **Technical Approach**:
    - Refine the `Dockerfile` to use multi-stage builds for smaller, more secure production images.
    - Ensure all secrets and environment variables are handled correctly.
    - Set up a basic CI/CD pipeline using GitHub Actions to build, test, and (optionally) deploy the application.
- **Implementation Steps**:
    1. Optimize the `Dockerfile` and `docker-compose.yml` for a production environment.
    2. Create a GitHub Actions workflow file to run tests on every push.
