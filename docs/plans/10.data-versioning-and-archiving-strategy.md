# Plan: Data Versioning and Archiving Strategy

This document outlines the plan for implementing a non-destructive, versioned data management system using an active/inactive status approach.

## 1. Problem Statement

The current data management approach involves destructive updates and deletions. This can lead to irreversible data loss, complicates auditing, and makes it difficult for users to recover or reactivate their accounts and associated data. A more resilient system is needed that preserves data history.

## 2. Requirements

### Functional Requirements
- **Data Versioning**: When a record (User, Board, List, Card) is updated, the original record is preserved and marked as inactive, and a new, active record is created with the updated information.
- **Non-Destructive Deletes**: When a record is "deleted," it is marked as inactive instead of being removed from the database.
- **Reactivation**: Users should be able to reactivate their accounts or restore "deleted" items. This will make the most recent inactive version active again.
- **Data Retrieval**: By default, API queries must only return active records.
- **History Access**: The system should provide a mechanism to access historical or inactive data for auditing or restoration purposes.

### Non-Functional Requirements
- **Audit Trail**: All historical versions of data must be maintained.
- **Data Integrity**: The system must ensure that only one version of a record is active at any given time.
- **Performance**: The performance of queries for active data should not be significantly degraded.

## 3. Proposed Technical Approach: Active/Inactive Versioning

This approach introduces versioning fields to the core data models.

### Prisma Schema Modifications

We will add `status`, `version`, and a `entityId` to each core model (`User`, `Board`, `List`, `Card`). The `id` will be unique to the version, while `entityId` will be the identifier for the object across all its versions.

```prisma
// Example for Board model
model Board {
  id          String   @id @default(cuid()) // Unique ID for this version
  boardId     String   @default(cuid())    // ID linking all versions of a board
  version     Int
  status      Status   @default(ACTIVE)

  name        String
  description String?
  // ... other fields and relations

  @@unique([boardId, version])
  @@index([boardId, status])
}

// Similar changes for User, List, and Card models

enum Status {
  ACTIVE
  INACTIVE
  ARCHIVED // For the contrarian challenge
}
```

### Data Modification Logic

-   **Create**: A new entity is created with `version: 1` and `status: ACTIVE`. A new `entityId` (e.g., `boardId`) is generated.
-   **Update**:
    1.  Find the current `ACTIVE` record for the given `entityId`.
    2.  Set its `status` to `INACTIVE`.
    3.  Create a new record with the same `entityId`, an incremented `version`, `status: ACTIVE`, and the updated data.
-   **Delete**:
    1.  Find the current `ACTIVE` record for the given `entityId`.
    2.  Set its `status` to `INACTIVE`.
-   **Reactivate**:
    1.  Find the most recent `INACTIVE` record for the given `entityId`.
    2.  Set its `status` to `ACTIVE`.
    3.  If there is another `ACTIVE` record, it should be marked `INACTIVE`.

## 4. Implementation Steps

1.  **[✅] Update Prisma Schema**:
    -   Add a `Status` enum to `schema.prisma`.
    -   For `User`, `Board`, `List`, and `Card` models, add the following fields:
        -   `entityId: String` (or `userId`, `boardId`, etc.) to group versions.
        -   `version: Int` to order versions.
        -   `status: Status @default(ACTIVE)` to mark the record's state.
    -   Update unique constraints and indexes.

2.  **[✅] Generate & Run Migration**:
    -   Run `npx prisma migrate dev --name add-data-versioning` to apply schema changes.

3.  **[✅] Refactor Backend Services**:
    -   Update all `create` functions to initialize `version: 1` and `status: ACTIVE`.
    -   Modify `update` functions to implement the versioning logic (deactivate old, create new active).
    -   Change `delete` functions to be non-destructive (set `status: INACTIVE`).
    -   Create `reactivate` functions for each service.

4.  **[✅] Update API Endpoints**:
    -   Modify all `GET` endpoints to include `where: { status: 'ACTIVE' }` by default in Prisma queries.
    -   Optionally, add a query parameter like `?include_inactive=true` for administrative or history-viewing purposes.

5.  **[✅] Adjust Frontend Logic**:
    -   Ensure the UI correctly handles the "deactivation" of items.
    -   Update Redux Toolkit and RTK Query logic to align with the new API behavior.
    -   Implement UI features for data restoration or viewing history if required.

6.  **[✅] Testing**:
    -   Write unit tests for the new service logic (update, delete, reactivate).
    -   Write integration tests to ensure API endpoints correctly filter by status.
    -   Create E2E tests for the user-facing "delete" and "restore" workflows.

## 5. Contrarian Challenge: The "Archive" Approach

Instead of an `isActive` flag, we could move inactive records to separate "archive" tables (e.g., `BoardArchive`, `ListArchive`).

-   **Schema**: Create a duplicate `...Archive` table for each main table.
-   **Logic**:
    -   **Update/Delete**: Instead of flagging, the original record is moved from the main table to the corresponding archive table. A new record is created in the main table for updates.
    -   **Restore**: The record is moved back from the archive table to the main table.
-   **Pros**:
    -   Primary tables remain clean and potentially smaller, leading to faster queries on active data.
    -   No need for `where: { status: 'ACTIVE' }` in every query, simplifying data access logic.
-   **Cons**:
    -   More complex logic for moving records between tables.
    -   Schema duplication makes migrations and maintenance more cumbersome.
    -   Restoring data with all its relations intact (e.g., a board with all its lists and cards) becomes a complex transactional operation.
    -   Querying the history of a single entity requires `UNION` operations across two tables.

While this approach has benefits for query performance on active data, the complexity it introduces likely outweighs the advantages for this application's scale.

## 6. Optional Reflection

Implementing this change will improve the application's resilience to undesired data modifications, foster accountability, and facilitate user reactivation. It ensures that historical data remains accessible for auditing purposes and improves the user experience by preventing the loss of data.
