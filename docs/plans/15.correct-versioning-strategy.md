# Plan 15: Correct and Finalize Data Versioning Strategy

> **Status: ✅ COMPLETED**
>
> This plan outlines the final, successful strategy for implementing data versioning. All implementation steps have been completed, and the solution has been verified by the integration test suite.

## 1. Problem Statement

The initial implementation of the data versioning and archival feature has proven to be buggy and difficult to stabilize. The core issue stems from a misunderstanding of how to correctly model versioned relationships in a relational database.

The primary conflict was between:
1.  The desire to use a **persistent ID** (e.g., `boardId`) to link a child (e.g., a `List`) to its conceptual parent.
2.  The database's strict requirement that a foreign key must point to a column that is **guaranteed to be unique**.

Our persistent `boardId` is *not* unique on its own (as multiple versions share it), which caused cascading foreign key constraint errors during `UPDATE` and `MOVE` operations. Attempts to fix this led to further complications and failing tests. This plan outlines the correct and final technical approach to resolve these issues.

## 2. Requirements

- **Functional:**
    - Implement a robust archival strategy for Boards, Lists, and Cards.
    - When an entity is modified (e.g., renamed, moved), a new version of that entity must be created, and the old version must be marked as `INACTIVE`.
    - This versioning operation **must not** duplicate the entity's children. For example, versioning a Board should not create new versions of all its Lists and Cards.
    - "Deleting" an entity should mark it as `INACTIVE` but preserve it in the database.
    - The API must correctly serve the `ACTIVE` version of any entity and its children.
- **Non-Functional:**
    - The solution must be efficient and avoid unnecessary database writes.
    - The database schema must be relationally sound and pass Prisma's validation.
    - The entire integration test suite must pass, confirming the backend logic is correct.
- **Future-Proofing:**
    - The data model must support a full audit history and "undo/redo" functionality in the future.

## 3. Technical Approach

The core of the solution is to distinguish between an entity's **persistent identifier** (for grouping versions) and its **version-specific primary key** (for database relations).

1.  **Schema Design:**
    - **Primary Key (`id`):** A `cuid()`, guaranteed unique for every single row/version in a table. **This will be used for all database relations.**
    - **Persistent ID (`boardId`, `listId`, `cardId`):** A `cuid()` that is shared across all versions of a single conceptual entity. This is used for querying and grouping.
    - **Foreign Keys:** A child's foreign key field (e.g., `List.boardId`) will now store the `id` (primary key) of its parent's specific version.

2.  **Versioning Logic (on Update/Move):**
    When an entity is versioned (e.g., a Board is renamed), the following atomic transaction will occur:
    1.  Find the current `ACTIVE` version of the Board.
    2.  Create a new `Board` record (the new version), which gets a new primary key `id`. It will share the same persistent `boardId` as the old version.
    3.  Mark the old `Board` record as `INACTIVE`.
    4.  **Crucially, update all immediate children (`List` records) to point to the new Board version.** This is a single, efficient `UPDATE` command: `UPDATE lists SET boardId = <new_board_version_id> WHERE boardId = <old_board_version_id>`.
    5.  The children (`Lists` and `Cards`) are **not** versioned or duplicated themselves.

This approach is efficient, maintains data integrity, and fully enables the desired archival functionality.

## 4. Implementation Steps

1.  **✅ Correct the Prisma Schema (`prisma/schema.prisma`):**
    - Revert the schema to a state that supports versioning (`version`, `status` fields).
    - Define relations to point to the parent's primary key (`id`), not its persistent ID.
    - Example for `List`:
      ```prisma
      model List {
        id        String   @id @default(cuid())
        listId    String   @default(cuid()) // Persistent ID
        // ... version, status, etc.
        boardId   String // This will store the Board's primary key `id`
        board     Board    @relation(fields: [boardId], references: [id], onDelete: Cascade)
        // ...
      }
      ```
    - Ensure `@@unique([boardId, version])` constraints are in place for all versioned models.

2.  **✅ Reset and Migrate the Database:**
    - Execute `npx prisma migrate reset --force` to ensure a clean slate and apply the corrected schema. This will wipe the existing data.

3.  **✅ Refactor Backend API Routes:**
    - **`boards.ts`:**
        - `PUT /:id`: Implement the new transaction logic: create new version, deactivate old, and run `prisma.list.updateMany` to retarget children.
        - `DELETE /:id`: Update to simply mark the board and its descendants as `INACTIVE`.
    - **`lists.ts`:**
        - `PUT /:id` & `PUT /:id/move`: Implement the new transaction logic, including the `prisma.card.updateMany` call to retarget child cards.
    - **`cards.ts`:**
        - `PUT /:id` & `PUT /:id/move`: Implement the versioning logic (no children to update).
    - Ensure all `GET` endpoints correctly query for the `ACTIVE` version of an entity.

4.  **✅ Repair Integration Test Suite (`tests/integration/*.ts`):**
    - Systematically update all tests to align with the new API behavior.
    - Assertions must now check for `INACTIVE` old versions and correctly updated foreign keys on child objects.
    - The goal is to get all 29 tests passing.

## 5. Testing Strategy

- The primary verification tool will be the integration test suite (`npm run test:integration`).
- Each API endpoint (`create`, `read`, `update`, `delete`, `move`) will be tested to ensure it behaves as expected under the new versioning model.
- Tests will explicitly check that child entities are correctly re-parented after a parent is versioned.

## 6. Risks & Mitigation

- **Risk:** The transactional logic is complex. An error could leave the database in an inconsistent state.
- **Mitigation:** All versioning operations will be wrapped in `prisma.$transaction`. This guarantees that if any step fails (e.g., updating the children), the entire operation is rolled back, ensuring data atomicity.
- **Risk:** Forgetting to update a route or test.
- **Mitigation:** A systematic review of all routes and tests, with the final "all green" test run serving as the definition of done.
