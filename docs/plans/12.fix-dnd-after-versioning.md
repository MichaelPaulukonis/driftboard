# Plan: Fix Drag-and-Drop After Data Versioning

**Date:** July 13, 2025

## 1. Problem Statement

Following the implementation of the data versioning strategy (`10.data-versioning-and-archiving-strategy.md`), the drag-and-drop (DND) functionality for both cards and lists has stopped working correctly. The core issue is that the frontend components and backend API endpoints for move operations were designed for the old data model (with a single, mutable `id`) and have not been updated to support the new versioned schema (using `entityId`, `version`, and `status`).

Optimistic UI updates are likely failing, and the backend is not persisting moves correctly, leading to a broken user experience.

## 2. Requirements

### Functional Requirements
- **[ ] Restore Card DND**: Users must be able to reorder cards within a list and move them between lists.
- **[ ] Restore List DND**: Users must be able to reorder lists on a board.
- **[✅] Data Persistence**: All moves must be correctly persisted to the database according to the new versioning logic (i.e., marking the old version `INACTIVE` and creating a new `ACTIVE` version). *(Backend logic is mostly in place, but buggy for lists).*
- **[ ] Optimistic UI**: The UI must provide immediate visual feedback during DND operations, correctly handling the new data structures returned by the API.

### Non-Functional Requirements
- **[ ] Code Clarity**: The updated code should clearly distinguish between a version's unique `id` and the persistent `entityId` (e.g., `cardId`).
- **[ ] Test Coverage**: The fix must be validated by both manual and automated tests.

## 3. Investigation & Proposed Fixes

The breakage stems from a data model mismatch between the frontend's expectations and the backend's new versioning reality. Here’s a breakdown of the likely problem areas and the proposed solution.

### 3.1. Root Cause Analysis

1.  **Backend API Mismatch**:
    - The `move` endpoints (e.g., `PUT /api/cards/:id/move`) are likely still using the version-specific `id` instead of the persistent `entityId` (e.g., `cardId`).
    - The service logic for these endpoints needs to be updated to perform the "update-as-new-version" flow: mark the old record as `INACTIVE` and create a new `ACTIVE` record with the updated `position` and/or `listId`.

2.  **Frontend Logic Mismatch**:
    - **`@dnd-kit` Handlers**: The `handleDragEnd` function is probably sending the wrong identifier to the API.
    - **RTK Query Mutations**: The `moveCard` and `moveList` mutations in the API slice are sending incorrect data and, more importantly, their optimistic update logic is not designed to handle the response, which now contains a *new* version of the object with a *new* `id`.

### 3.2. Proposed Solution

The most robust solution is to align both the frontend and backend with the new versioning paradigm.

**Solution A: Full Alignment (Recommended)**

This approach updates all layers to work with the new data model.

-   **Pros**:
    -   Creates a consistent and predictable data flow.
    -   Maintains the benefits of optimistic updates for a smooth UX.
    -   Correctly implements the data versioning strategy for all operations.
-   **Cons**:
    -   Requires careful implementation of the optimistic update logic, which can be complex.

**Solution B: Fallback (Simpler but Slower UX)**

If optimistic updates prove too difficult to implement correctly under the new model, we can simplify the frontend logic.

-   **Logic**: Instead of trying to predict the result of the move, the frontend would simply fire the API call and, upon success, invalidate the cached data for the board, triggering a full refetch.
-   **Pros**:
    -   Much simpler to implement on the frontend.
    -   Less prone to UI state-mismatch bugs.
-   **Cons**:
    -   Degrades user experience. The user would see a loading state or a "snap" as the UI waits for the server to respond and the data to be refetched.
    -   Less efficient, as it requires more network traffic.

**Decision**: We will proceed with **Solution A**, as it preserves the intended user experience. We will keep Solution B as a potential fallback if we encounter insurmountable issues with the optimistic updates.

## 4. Implementation Steps

1.  **[ ] Update Backend API & Services (Highest Priority)**
    -   **File(s)**: `src/backend/routes/cards.ts`, `src/backend/routes/lists.ts`.
    -   **Action**:
        -   **[✅]** Modify the routes to use the entity identifier in the URL, e.g., `PUT /api/cards/:cardId/move`.
        -   **[ ]** In the service, update the `move` logic. It should:
            1.  **[✅]** Find the current `ACTIVE` record using the provided `cardId`.
            2.  **[✅]** In a transaction, set its `status` to `INACTIVE`.
            3.  **[✅]** Create a new record with the same `cardId`, an incremented `version`, `status: ACTIVE`, and the new `position` and/or `listId`.
            4.  **[ ] (For Lists)** Ensure all `ACTIVE` cards from the old list version are re-associated with the new list version.
            5.  **[✅]** Return the newly created record.

2.  **[✅] Update Frontend RTK Query Mutations**
    -   **File(s)**: `src/frontend/src/api/api.ts`.
    -   **Action**:
        -   **[✅]** Update the `moveCard` and `moveList` mutations to call the new backend endpoints (e.g., `/api/cards/${cardId}/move`).
        -   **[✅]** Ensure the body of the request contains the necessary data (new `listId`, `position`).

3.  **[ ] Fix Optimistic Update Logic**
    -   **File(s)**: `src/frontend/src/api/api.ts`, `src/frontend/src/store/boardsSlice.ts`.
    -   **Action**:
        -   **[ ]** Revise the `onQueryStarted` logic for the move mutations.
        -   **[ ]** The optimistic update patch must now *replace* the old card/list object in the Redux store with the new object returned from the successful mutation. The logic needs to find the item to replace based on `cardId` or `listId`.

4.  **[ ] Update Frontend Component Logic**
    -   **File(s)**: `src/frontend/src/pages/BoardDetailPage.tsx`.
    -   **Action**: **[ ]** Ensure that the `id` passed to the `@dnd-kit` components is the version-specific `id`, but the `id` used in the `handleDragEnd` logic for API calls is the persistent `entityId` (`cardId` or `listId`). **This is the primary frontend bug.**

## 5. Testing Strategy

A multi-layered testing approach is critical to validate the fix.

### 5.1. Manual Testing (To be performed first)

1.  **Setup**: Launch the application and navigate to a board with several cards and lists.
2.  **Card Reordering**:
    -   Drag a card to a new position within the same list.
    -   **Verification**: Confirm it stays in place after a page refresh. Check the network tab to see the `move` API call succeed. Check the database to confirm a new version was created.
3.  **Card Moving**:
    -   Drag a card from one list to another.
    -   **Verification**: Confirm it stays in the new list after a refresh. Verify via network tab and database inspection.
4.  **List Reordering**:
    -   Drag a list to a new position.
    -   **Verification**: Confirm it stays in place after a refresh. Verify via network tab and database inspection.
5.  **Edge Cases**:
    -   Rapidly move the same card multiple times.
    -   Move a card, then immediately move another.

### 5.2. Automated Testing (To be implemented after manual confirmation)

1.  **[ ] Integration Tests (`tests/integration/`)**:
    -   **File(s)**: `cards.test.ts`, `lists.test.ts`.
    -   **Action**: **[ ]** Update the tests for the `move` endpoints.
    -   **Assertions**:
        -   **[ ]** Verify the endpoint returns a `200 OK` with the new version of the object.
        -   **[ ]** Add an assertion to fetch the entity by its `entityId` and confirm that the old version is now `INACTIVE` and the new version is `ACTIVE` with the updated properties.
        -   **[ ] (For Lists)** Add an assertion to confirm that cards were correctly moved to the new list version.

2.  **[ ] End-to-End Tests (`tests/e2e/`)**:
    -   **File(s)**: `dnd.spec.ts`.
    -   **Action**: Review and update the existing DND tests. They may not need significant changes if the UI behavior is restored, but they must be run to confirm they pass.
    -   **Assertions**: The existing assertions (checking the final visual state of the board) should still be valid.

## 6. Risks & Mitigation

-   **Risk**: The optimistic update logic becomes overly complex and introduces UI bugs (e.g., flickering, duplicate items).
    -   **Mitigation**: We will timebox the effort to fix the optimistic updates. If it proves too difficult, we will revert to the simpler "invalidate and refetch" strategy (Solution B) to unblock progress and create a separate task to revisit optimistic updates later.
-   **Risk**: Performance issues due to creating new rows for every move.
    -   **Mitigation**: This is an accepted trade-off of the versioning strategy. For now, we will accept it. If performance becomes a noticeable issue, we can explore alternative strategies in a future phase.

## 7. Dependencies

-   **[✅]** A stable and passing integration test suite (completed in `11.fix-integration-tests.md`).
-   **[✅]** A clear understanding of the current RTK Query and `@dnd-kit` implementation.